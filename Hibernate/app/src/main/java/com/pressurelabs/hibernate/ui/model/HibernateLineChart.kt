package com.pressurelabs.hibernate.ui.model

import com.pressurelabs.hibernate.data.models.SleepEntry
import com.pressurelabs.hibernate.util.Conversion
import lecho.lib.hellocharts.model.Axis
import lecho.lib.hellocharts.model.Line
import lecho.lib.hellocharts.model.LineChartData
import lecho.lib.hellocharts.model.PointValue
import lecho.lib.hellocharts.util.ChartUtils
import timber.log.Timber
import java.sql.Time
import java.sql.Timestamp
import java.text.SimpleDateFormat
import java.util.*

class HibernateLineChart(data: List<SleepEntry>) {

    private object Blankify{
        fun fill(data:List<SleepEntry>, howMany:Int):List<SleepEntry> {
            var copy = data.toMutableList()
            var listPointer = data.size
            if (listPointer==0) {
                var cal = Calendar.getInstance()
                var timeNow:Long = cal.timeInMillis
                copy.add(SleepEntry(Timestamp(timeNow),Timestamp(timeNow)))
                listPointer++
            }

            while(listPointer<howMany){
                var last = copy[listPointer-1]
                var next = Conversion.add_one_day(last.start.time)
                copy.add(SleepEntry(Timestamp(next), Timestamp(next)))
                listPointer++
            }
            return copy
        }
    }

    var data = data
    fun Create(entries: Int): LineChartData {
        ensureTimestampDataIntegrity(data,entries)
        return AssembleLineChartData(data,entries)
    }

    private fun ensureTimestampDataIntegrity(dataToEnsure: List<SleepEntry>, entries: Int) {
        data = Blankify.fill(dataToEnsure,entries)
    }

    private fun getXAxis(data: List<SleepEntry>, entryCount: Int): Axis {
        // If it 's the first time install app

        // Otherwise continue population
        var xAxisValues = mutableListOf<Float>()
        var entries = 0

        while (entries<entryCount) {
            xAxisValues.add(entries.toFloat())
            entries++
        }
        Timber.d("Entries are $entries")
        // Parse Timestamps to readable labels
        val simpleFormat = SimpleDateFormat("MM-dd")
        var xAxisLabels = data.indices
                .map {
                    // Transfer over all data -> String
                    simpleFormat.format(data[it].start)
                }.toMutableList()

        var currentSizeOfXLabels = xAxisLabels.size
        while (currentSizeOfXLabels<entryCount){
            var lastTimeStamp:Long = 1
            try {
                lastTimeStamp= data[currentSizeOfXLabels-1].start.time
            } catch(e:Exception) {
                lastTimeStamp= data[currentSizeOfXLabels-2].start.time
            }

            var nextTimeStamp: Timestamp = Timestamp(lastTimeStamp+ Conversion.d_to_ms(1))
            var label = simpleFormat.format(nextTimeStamp)
            // Add 1 to last timestamp
            xAxisLabels.add(label)
            currentSizeOfXLabels=xAxisLabels.size
        }
        Timber.d("Size of labels ${xAxisLabels.size}")
        return Axis.generateAxisFromCollection(xAxisValues,xAxisLabels)
    }

    private fun getYAxis(data:List<SleepEntry>): Axis {
        var mYAxis = Axis()
        return mYAxis
    }
    private fun AssembleLineChartData(data:List<SleepEntry>, numberOfData:Int): LineChartData {
        // Build the line chart data
        val values = toPointValues(data,numberOfData)
        val line = getLineFormatting(values)
        val lines = ArrayList<Line>()
        lines.add(line)

        val lineChartData = LineChartData()
        lineChartData.lines = lines

        // Set X axis
        val axisX = getXAxis(data,numberOfData)
        axisX.name = "Day"
        lineChartData.axisXBottom = axisX
        lineChartData

        // Set Y Axis
        val axisY = getYAxis(data)
        axisY.isAutoGenerated = true
        axisY.name = "Cycles Slept"
        lineChartData.axisYLeft = axisY
        return lineChartData
    }

    private fun getLineFormatting(values: List<PointValue>): Line {
        var line = Line(values)
        line.isFilled =true
        line.color = ChartUtils.COLOR_BLUE
        line.isCubic = true
        line.setHasLabelsOnlyForSelected(true)
        return line
    }


    private fun toPointValues(data: List<SleepEntry>, entryCount:Int): List<PointValue> {
        val ptValues:MutableList<PointValue> = data.indices
                .map {
                    // Transfer over all data -> Point Value Objects
                    PointValue(it.toFloat(),data[it].cycles)
                }
                .toMutableList()

        // Fills with blank values for the rest
        do {
            var currentSize = ptValues.size.toFloat()
            var emptyPtValue = PointValue(currentSize,0f)
            ptValues.add(emptyPtValue)
        } while (ptValues.size<=entryCount)

        return ptValues
    }

}